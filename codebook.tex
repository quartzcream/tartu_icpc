\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{titlesec}
\usepackage{enumerate}
\usepackage{amsmath, amsfonts, amssymb, amsthm}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{forloop}
\usepackage{hyperref}
\usepackage{pdflscape}
\usepackage{multicol}
\usepackage{physics}
\usepackage{harpoon}
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\phi}{\varphi}
\renewcommand{\theta}{\vartheta}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\qed}{\hfill$\blacksquare$}
\newcommand{\amp}{\, \& \,}
\newcommand{\imp}{\Rightarrow}
\renewcommand{\O}{\mathcal{O}}
\usepackage{listings}
\usepackage{xcolor}
\lstset{language=C++,
  aboveskip=0mm,belowskip=0mm,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{purple}\ttfamily,
  commentstyle=\color{red}\ttfamily,
  breaklines = true}
\renewcommand{\theenumi}{\alph{enumi}}
\DeclareMathOperator{\orient}{orient}
\DeclareMathOperator{\side}{side}
\DeclareMathOperator{\dist}{dist}
\DeclareMathOperator{\prp}{perp}
%\newcommand*{\vv}[1]{\overrightharp{\ensuremath{#1}}}
\newcommand{\vv}[1]{\overline{#1}}
\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\usepackage[hmarginratio=1:1,top=20mm, bottom=5mm, columnsep=0mm, left=17mm, right=10mm]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact
\usepackage{fancyhdr} % Proper control over header
\usepackage{minted}
\usepackage{etoolbox}
\AtBeginEnvironment{minted}{\fontsize{10}{10}\selectfont}
\BeforeBeginEnvironment{minted}{\vspace*{-2.5mm}}
\AfterEndEnvironment{minted}{\vspace*{-4.5mm}}
\usemintedstyle{tartu_icpc}
\titleformat*{\section}{\bfseries}
\titlespacing*{\section}{10mm}{0ex}{0ex}
\title{\textbf{University of Tartu ICPC Team Notebook (2018-2019)}}
\date{\today}
\pagestyle{fancy}
\fancyhf{}
\lhead{University of Tartu}
\rhead{\thepage}
\setlength{\headsep}{0mm}
\hyphenpenalty=2000
\exhyphenpenalty=2000
\tolerance=2000
\emergencystretch=10pt
\binoppenalty=10
\relpenalty=10
\makeatletter
\renewcommand\tableofcontents{%
    \@starttoc{toc}%
}
\makeatother
\begin{document}
\begin{landscape}
\setlength\columnsep{10mm}
\begin{multicols*}{2}
\begin{center}
	\smallskip
  \Large{\textbf{University of Tartu ICPC Team Notebook (2018-2019)}}
	\today
\end{center}
\tableofcontents
\par\noindent\rule{\textwidth}{0.4pt}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, texcomments=true, mathescape=true]{bash}
alias g++='g++ -g -Wall -Wshadow -DCDEBUG' #.basrc
alias a='setxkbmap us -option'
alias m='setxkbmap us -option caps:escape'
alias ma='setxkbmap us -variant dvp -option caps:escape'
#settings
gsettings set org.compiz.core:/org/compiz/profiles/Default/plugins/core/ hsize 4
gsettings set org.gnome.desktop.wm.preferences focus-mode 'sloppy'
set si cin #.vimrc
set ts=4 sw=4 noet
set cb=unnamed
(global-set-key (kbd "C-x <next>") 'other-window) #.emacs
(global-set-key (kbd "C-x <prior>") 'previous-multiframe-window)
(global-set-key (kbd "C-M-z") 'ansi-term)
(global-linum-mode 1)
(column-number-mode 1)
(show-paren-mode 1)
(setq-default indent-tabs-mode nil)
valgrind --vgdb-error=0 ./a <inp & #valgrind
gdb a
target remote | vgdb
\end{minted}
\section{crc.sh}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, texcomments=true, mathescape=true]{bash}
#!/bin/envbash
for j in `seq 1 1 200`; do
  sed '/^\s*$/d' $1 | head -$j | tr -d '[[:space:]]' | cksum | cut -f1 -d ' ' | tail -c 5 #whistespaces don't matter.
done #there shouldn't be any COMMENTS.
#copy lines being checked to separate file.
# \$ ./crc.sh tmp.cpp | grep XXXX
\end{minted}
\section{gcc ordered set}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
#define DEBUG(...) cerr << \_\_VA\_ARGS\_\_ << endl;
#ifndef CDEBUG
#undef DEBUG
#define DEBUG(...) ((void)0);
#define NDEBUG
#endif
#define ran(i, a, b) for (auto i = (a); i < (b); i++)
#include <bits/stdc++.h>
typedef long long ll;@ $ \hfill #1736 $ @
typedef long double ld;
using namespace std;
#include <ext/pb\_ds/assoc\_container.hpp>
#include <ext/pb\_ds/tree\_policy.hpp>
using namespace __gnu_pbds;@ $ \hfill #5119 $ @
template <typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,
  tree_order_statistics_node_update>;
int main() {
  ordered_set<int> cur;@ $ \hfill #3802 $ @
  cur.insert(1);
  cur.insert(3);
  cout << cur.order_of_key(2)
       << endl; // the number of elements in the set less than 2
  cout << *cur.find_by_order(0)@ $ \hfill #0578 $ @
       << endl; // the 0-th smallest number in the set(0-based)
  cout << *cur.find_by_order(1)
       << endl; // the 1-th smallest number in the set(0-based)
}@ $ \hfill %4198 $ @
\end{minted}
\section{Triangle centers}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
const double min_delta = 1e-13;
const double coord_max = 1e6;
typedef complex<double> point;
point A, B, C; // vertixes of the triangle
bool collinear() {@ $ \hfill #0823 $ @
  double min_diff = min(abs(A - B), min(abs(A - C), abs(B - C)));
  if (min_diff < coord_max * min_delta) return true;
  point sp = (B - A) / (C - A);
  double ang = M_PI / 2 - abs(abs(arg(sp)) - M_PI / 2);
  return ang < min_delta; // positive angle with the real line
}@ $ \hfill #8446 $ @@ $ \hfill %8446 $ @
point circum_center() {
  if (collinear()) return point(NAN, NAN);
  // squared lengths of sides
  double a2 = norm(B - C);
  double b2 = norm(A - C);
  double c2 = norm(A - B);@ $ \hfill #6715 $ @
  // barycentric coordinates of the circumcenter
  double c_A = a2 * (b2 + c2 - a2); // sin(2 * alpha) works also
  double c_B = b2 * (a2 + c2 - b2);
  double c_C = c2 * (a2 + b2 - c2);
  double sum = c_A + c_B + c_C;
  c_A /= sum;@ $ \hfill #9407 $ @
  c_B /= sum;
  c_C /= sum;
  return c_A * A + c_B * B + c_C * C; // cartesian
}@ $ \hfill %6856 $ @
point centroid() { // center of mass
  return (A + B + C) / 3.0;
}
point ortho_center() { // euler line
  point O = circum_center();@ $ \hfill #3895 $ @
  return O + 3.0 * (centroid() - O);
};
point nine_point_circle_center() { // euler line
  point O = circum_center();
  return O + 1.5 * (centroid() - O);@ $ \hfill #8193 $ @
};@ $ \hfill %3031 $ @
point in_center() {
  if (collinear()) return point(NAN, NAN);
  double a = abs(B - C); // side lenghts
  double b = abs(A - C);
  double c = abs(A - B);@ $ \hfill #5954 $ @
  // trilinear coordinates are (1,1,1)
  double sum = a + b + c;
  a /= sum;
  b /= sum;
  c /= sum;                     // barycentric
  return a * A + b * B + c * C; // cartesian
}@ $ \hfill #4892 $ @@ $ \hfill %4892 $ @
\end{minted}
\end{multicols}
\boldmath
\setlength\columnsep{5mm}
\begin{multicols}{3}
\section{2D geometry}
\noindent
Define $\orient(A, B, C) = \vv{AB} \times \vv{AC}$. CCW iff $>0$. \\
Define $\prp((a, b)) = (-b, a)$. The vectors are orthogonal. \\
For line $ax + by = c$ def $\vv{v} = (-b, a)$. \\
Line through $P$ and $Q$ has $\vv{v} = \vv{PQ}$ and $c = \vv{v} \times P$. \\
$\side_l (P) = \vv{v_l} \times P - c_l$ sign determines which side $P$ is on from $l$. \\
$\dist_l (P) = \side_l (P) / \norm{v_l}$ squared is integer. \\
Sorting points along a line: comparator is $\vv{v} \cdot A < \vv{v} \cdot B$. \\
Translating line by $\vv{t}$: new line has $c' = c + \vv{v} \times \vv{t}$. \\
Line intersection: is $(c_{l} \vv{v}_m - c_m \vv{v}_l) / (\vv{v}_l \times \vv{v}_m)$. \\
Project $P$ onto $l$: is $P - \prp(v) \side_l(P) / \norm{v}^2$. \\
Angle bisectors: $\vv{v} = \vv{v}_l / \norm{\vv{v}_l} + \vv{v}_m / \norm{\vv{v}_m}$ \\
$c = c_l / \norm{\vv{v}_l} + c_m / \norm{\vv{v}_m}$. \\
$P$ is on segment $AB$ iff $\orient(A, B, P) = 0$ and $\vv{PA} \cdot \vv{PB} \le 0$. \\
Proper intersection of $AB$ and $CD$ exists iff $\orient(C, D, A)$ and $\orient(C, D, B)$
have opp. signs and $\orient(A, B, C)$ and $\orient(A, B, D)$ have opp. signs. Coordinates: \\
\begin{equation*}
  \frac{A \orient(C, D, B) - B \orient(C, D, A)}{\orient(C, D, B) - \orient(C, D, A)}.
\end{equation*}
Circumcircle center:
\lstinputlisting[firstline = 1, lastline = 4]{geometry_snippets.cpp}
Circle-line intersect:
\lstinputlisting[firstline = 7, lastline = 14]{geometry_snippets.cpp}
Circle-circle intersect:
\lstinputlisting[firstline = 17, lastline = 25]{geometry_snippets.cpp}
Tangent lines:
\lstinputlisting[firstline = 28, lastline = 36]{geometry_snippets.cpp}
\section{3D geometry}
\noindent
$\orient(P, Q, R, S) = (\vv{PQ} \times \vv{PR}) \cdot \vv{PS}$. \\
  $S$ above $PQR$ iff $>0$. \\
For plane $ax + by + cz = d$ def $\vv{n} = (a, b, c)$. \\
Line with normal $\vv{n}$ through point $P$ has $d = \vv{n} \cdot P$. \\
$\side_\Pi (P) = \vv{n} \cdot P - d$ sign determines side from $\Pi$. \\
$\dist_\Pi (P) = \side_\Pi (P) / \norm{\vv{n}}$. \\
Translating plane by $\vv{t}$ makes $d' = d + \vv{n} \cdot \vv{t}$. \\
Plane-plane intersection of has direction $\vv{n}_1 \times \vv{n}_2$ and
goes through $((d_1 \vv{n}_2 - d_2 \vv{n}_1) \times \vv{d}) / \norm{\vv{d}}^2$. \\
Line-line distance:
\lstinputlisting[firstline = 39, lastline = 43]{geometry_snippets.cpp}
Spherical to Cartesian: \\ $(r \cos \phi \cos \lambda, r \cos \phi \sin \lambda, r \sin \phi)$. \\
Sphere-line intersection:
\lstinputlisting[firstline = 46, lastline = 52]{geometry_snippets.cpp}
Great-circle distance between points $A$ and $B$ is $r \angle AOB$. \\
Spherical segment intersection:
\lstinputlisting[firstline = 55, lastline = 87]{geometry_snippets.cpp}
Angle between spherical segments $AB$ and $AC$ is angle between $A \times B$ and $A \times C$. \\
Oriented angle: subtract from $2\pi$ if mixed product is negative. \\
Area of a spherical polygon:
\begin{equation*}
  r^2 [ \text{sum of interior angles} - (n - 2)\pi ].
\end{equation*}
\end{multicols}
\unboldmath
\setlength\columnsep{10mm}
\begin{multicols*}{2}
\section{Seg-Seg intersection, halfplane intersection area}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct Seg {
  Vec a, b;
  Vec d() { return b - a; }
};
Vec intersection(Seg l, Seg r) {@ $ \hfill #6327 $ @
  Vec dl = l.d(), dr = r.d();
  if (cross(dl, dr) == 0) return {nanl(""), nanl("")};
  double h = cross(dr, l.a - r.a) / len(dr);
  double dh = cross(dr, dl) / len(dr);
  return l.a + dl * (h / -dh);@ $ \hfill #8893 $ @
}
// Returns the area bounded by halfplanes
double calc_area(const vector<Seg>& lines) {
  double lb = -HUGE_VAL, ub = HUGE_VAL;
  vector<Seg> slines[2];
  for (auto line : lines) {@ $ \hfill #1804 $ @
    if (line.b.y == line.a.y) {
      if (line.a.x < line.b.x) {
        lb = max(lb, line.a.y);
      } else {
        ub = min(ub, line.a.y);@ $ \hfill #6288 $ @
      }
    } else if (line.a.y < line.b.y) {
      slines[1].push_back(line);
    } else {
      slines[0].push_back({line.b, line.a});@ $ \hfill #3607 $ @
    }
  }
  ran(i, 0, 2) {
    sort(slines[i].begin(), slines[i].end(), [&](Seg l, Seg r) {
      if (cross(l.d(), r.d()) == 0)@ $ \hfill #4919 $ @
        return normal(l.d()) * l.a > normal(r.d()) * r.a;
      return (1 - 2 * i) * cross(l.d(), r.d()) < 0;
    });
  }
  // Now find the application area of the lines and clean up redundant
  // ones
  vector<double> ap_s[2];@ $ \hfill #9949 $ @
  ran(side, 0, 2) {
    vector<double>& apply = ap_s[side];
    vector<Seg> clines;
    for (auto line : slines[side]) {
      while (clines.size() > 0) {@ $ \hfill #3099 $ @
        Seg other = clines.back();
        if (cross(line.d(), other.d()) != 0) {
          double start = intersection(line, other).y;
          if (start > apply.back()) break;
        }@ $ \hfill #7856 $ @
        clines.pop_back();
        apply.pop_back();
      }
      if (clines.size() == 0) {
        apply.push_back(-HUGE_VAL);@ $ \hfill #0868 $ @
      } else {
        apply.push_back(intersection(line, clines.back()).y);
      }
      clines.push_back(line);
    }@ $ \hfill #8545 $ @
    slines[side] = clines;
  }
  ap_s[0].push_back(HUGE_VALL);
  ap_s[1].push_back(HUGE_VALL);
  double result = 0;@ $ \hfill #3234 $ @
  {
    double lb = -HUGE_VALL, ub;
    for (int i = 0, j = 0;
         i < (int)slines[0].size() && j < (int)slines[1].size();
         lb = ub) {@ $ \hfill #4531 $ @
      ub = min(ap_s[0][i + 1], ap_s[1][j + 1]);
      double alb = lb, aub = ub;
      Seg l[2] = {slines[0][i], slines[1][j]};
      if (cross(l[1].d(), l[0].d()) > 0) {
        alb = max(alb, intersection(l[0], l[1]).y);
      } else if (cross(l[1].d(), l[0].d()) < 0) {@ $ \hfill #2627 $ @
        aub = min(aub, intersection(l[0], l[1]).y);
      }
      alb = max(alb, lb);
      aub = min(aub, ub);
      aub = max(aub, alb);@ $ \hfill #8493 $ @
      ran(k, 0, 2) {
        double x1 =
          l[0].a.x + (alb - l[0].a.y) / l[0].d().y * l[0].d().x;
        double x2 =
          l[0].a.x + (aub - l[0].a.y) / l[0].d().y * l[0].d().x;
        result += (-1 + 2 * k) * (aub - alb) * (x1 + x2) / 2;
      }@ $ \hfill #9267 $ @
      if (ap_s[0][i + 1] < ap_s[1][j + 1]) {
        i++;
      } else {
        j++;
      }@ $ \hfill #3074 $ @
    }
  }
  return result;
}@ $ \hfill %0513 $ @
\end{minted}
\section{Convex polygon algorithms}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
typedef pair<int, int> Vec;
typedef pair<Vec, Vec> Seg;
typedef vector<Seg>::iterator SegIt;
#define F first
#define S second
#define MP(x, y) make\_pair(x, y)
ll dot(Vec &v1, Vec &v2) { return (ll)v1.F * v2.F + (ll)v1.S * v2.S; }
ll cross(Vec &v1, Vec &v2) {@ $ \hfill #6913 $ @
  return (ll)v1.F * v2.S - (ll)v2.F * v1.S;
}
ll dist_sq(Vec &p1, Vec &p2) {
  return (ll)(p2.F - p1.F) * (p2.F - p1.F) +
         (ll)(p2.S - p1.S) * (p2.S - p1.S);@ $ \hfill #3216 $ @
}@ $ \hfill %8008 $ @
struct Hull {
  vector<Seg> hull;
  SegIt up_beg;
  template <typename It>
  void extend(It beg, It end) { // O(n)
    vector<Vec> r;@ $ \hfill #4033 $ @
    for (auto it = beg; it != end; ++it) {
      if (r.empty() || *it != r.back()) {
        while (r.size() >= 2) {
          int n = r.size();
          Vec v1 = {r[n - 1].F - r[n - 2].F, r[n - 1].S - r[n - 2].S};
          Vec v2 = {it->F - r[n - 2].F, it->S - r[n - 2].S};
          if (cross(v1, v2) > 0) break;@ $ \hfill #3588 $ @
          r.pop_back();
        }
        r.push_back(*it);
      }
    }@ $ \hfill #6639 $ @
    ran(i, 0, (int)r.size() - 1) hull.emplace_back(r[i], r[i + 1]);
  }
  Hull(vector<Vec> &vert) {         // atleast 2 distinct points
    sort(vert.begin(), vert.end()); // O(n log(n))
    extend(vert.begin(), vert.end());@ $ \hfill #6560 $ @
    int diff = hull.size();
    extend(vert.rbegin(), vert.rend());
    up_beg = hull.begin() + diff;
  }@ $ \hfill %0722 $ @
  bool contains(Vec p) { // O(log(n))
    if (p < hull.front().F || p > up_beg->F) return false;
    {
      auto it_low = lower_bound(
        hull.begin(), up_beg, MP(MP(p.F, (int)-2e9), MP(0, 0)));
      if (it_low != hull.begin()) --it_low;@ $ \hfill #3373 $ @
      Vec a = {it_low->S.F - it_low->F.F, it_low->S.S - it_low->F.S};
      Vec b = {p.F - it_low->F.F, p.S - it_low->F.S};
      if (cross(a, b) < 0) // < 0 is inclusive, <=0 is exclusive
        return false;
    }@ $ \hfill #2197 $ @
    {
      auto it_up = lower_bound(hull.rbegin(),
        hull.rbegin() + (hull.end() - up_beg),
        MP(MP(p.F, (int)2e9), MP(0, 0)));
      if (it_up - hull.rbegin() == hull.end() - up_beg) --it_up;
      Vec a = {it_up->F.F - it_up->S.F, it_up->F.S - it_up->S.S};
      Vec b = {p.F - it_up->S.F, p.S - it_up->S.S};
      if (cross(a, b) > 0) // > 0 is inclusive, >=0 is exclusive
        return false;@ $ \hfill #7227 $ @
    }
    return true;
  }@ $ \hfill %1826 $ @
  // The function can have only one local min and max
  // and may be constant only at min and max.
  template <typename T>
  SegIt max(function<T(Seg &)> f) { // O(log(n))
    auto l = hull.begin();
    auto r = hull.end();
    SegIt b = hull.end();@ $ \hfill #8566 $ @
    T b_v;
    while (r - l > 2) {
      auto m = l + (r - l) / 2;
      T l_v = f(*l);
      T l_n_v = f(*(l + 1));@ $ \hfill #3586 $ @
      T m_v = f(*m);
      T m_n_v = f(*(m + 1));
      if (b == hull.end() || l_v > b_v) {
        b = l; // If max is at l we may remove it from the range.
        b_v = l_v;@ $ \hfill #7332 $ @
      }
      if (l_n_v > l_v) {
        if (m_v < l_v) {
          r = m;
        } else {@ $ \hfill #7279 $ @
          if (m_n_v > m_v) {
            l = m + 1;
          } else {
            r = m + 1;
          }@ $ \hfill #0656 $ @
        }
      } else {
        if (m_v < l_v) {
          l = m + 1;
        } else {@ $ \hfill #7311 $ @
          if (m_n_v > m_v) {
            l = m + 1;
          } else {
            r = m + 1;
          }@ $ \hfill #4469 $ @
        }
      }
    }
    T l_v = f(*l);
    if (b == hull.end() || l_v > b_v) {@ $ \hfill #9864 $ @
      b = l;
      b_v = l_v;
    }
    if (r - l > 1) {
      T l_n_v = f(*(l + 1));@ $ \hfill #5972 $ @
      if (b == hull.end() || l_n_v > b_v) {
        b = l + 1;
        b_v = l_n_v;
      }
    }@ $ \hfill #9086 $ @
    return b;
  }@ $ \hfill %9504 $ @
  SegIt closest(Vec p) { // p can't be internal(can be on border),
                         // hull must have atleast 3 points
    Seg &ref_p = hull.front(); // O(log(n))
    return max(function<double(Seg &)>(
      [&p, &ref_p](
        Seg &seg) { // accuracy of used type should be coord^-2
        if (p == seg.F) return 10 - M_PI;@ $ \hfill #0134 $ @
        Vec v1 = {seg.S.F - seg.F.F, seg.S.S - seg.F.S};
        Vec v2 = {p.F - seg.F.F, p.S - seg.F.S};
        ll c_p = cross(v1, v2);
        if (c_p > 0) { // order the backside by angle
          Vec v1 = {ref_p.F.F - p.F, ref_p.F.S - p.S};
          Vec v2 = {seg.F.F - p.F, seg.F.S - p.S};
          ll d_p = dot(v1, v2);@ $ \hfill #5063 $ @
          ll c_p = cross(v2, v1);
          return atan2(c_p, d_p) / 2;
        }
        ll d_p = dot(v1, v2);
        double res = atan2(d_p, c_p);@ $ \hfill #0469 $ @
        if (d_p <= 0 && res > 0) res = -M_PI;
        if (res > 0) {
          res += 20;
        } else {
          res = 10 - res;@ $ \hfill #7417 $ @
        }
        return res;
      }));
  }@ $ \hfill %8283 $ @
  template <int DIRECTION> // 1 or -1
  Vec tan_point(Vec p) {   // can't be internal or on border
    //-1 iff CCW rotation of ray from p to res takes it away from
    // polygon?
    Seg &ref_p = hull.front(); // O(log(n))
    auto best_seg = max(function<double(Seg &)>(
      [&p, &ref_p](@ $ \hfill #5209 $ @
        Seg &seg) { // accuracy of used type should be coord^-2
        Vec v1 = {ref_p.F.F - p.F, ref_p.F.S - p.S};
        Vec v2 = {seg.F.F - p.F, seg.F.S - p.S};
        ll d_p = dot(v1, v2);
        ll c_p = DIRECTION * cross(v2, v1);@ $ \hfill #9762 $ @
        return atan2(c_p, d_p); // order by signed angle
      }));
    return best_seg->F;
  }@ $ \hfill %5037 $ @
  SegIt max_in_dir(Vec v) { // first is the ans. O(log(n))
    return max(
      function<ll(Seg &)>([&v](Seg &seg) { return dot(v, seg.F); }));
  }@ $ \hfill %9596 $ @
  pair<SegIt, SegIt> intersections(Seg l) { // O(log(n))
    int x = l.S.F - l.F.F;
    int y = l.S.S - l.F.S;
    Vec dir = {-y, x};
    auto it_max = max_in_dir(dir);@ $ \hfill #4740 $ @
    auto it_min = max_in_dir(MP(y, -x));
    ll opt_val = dot(dir, l.F);
    if (dot(dir, it_max->F) < opt_val ||
        dot(dir, it_min->F) > opt_val)
      return MP(hull.end(), hull.end());@ $ \hfill #0276 $ @
    SegIt it_r1, it_r2;
    function<bool(Seg &, Seg &)> inc_c([&dir](Seg &lft, Seg &rgt) {
      return dot(dir, lft.F) < dot(dir, rgt.F);
    });
    function<bool(Seg &, Seg &)> dec_c([&dir](Seg &lft, Seg &rgt) {
      return dot(dir, lft.F) > dot(dir, rgt.F);@ $ \hfill #0483 $ @
    });
    if (it_min <= it_max) {
      it_r1 = upper_bound(it_min, it_max + 1, l, inc_c) - 1;
      if (dot(dir, hull.front().F) >= opt_val) {
        it_r2 = upper_bound(hull.begin(), it_min + 1, l, dec_c) - 1;
      } else {@ $ \hfill #9409 $ @
        it_r2 = upper_bound(it_max, hull.end(), l, dec_c) - 1;
      }
    } else {
      it_r1 = upper_bound(it_max, it_min + 1, l, dec_c) - 1;
      if (dot(dir, hull.front().F) <= opt_val) {@ $ \hfill #9772 $ @
        it_r2 = upper_bound(hull.begin(), it_max + 1, l, inc_c) - 1;
      } else {
        it_r2 = upper_bound(it_min, hull.end(), l, inc_c) - 1;
      }
    }@ $ \hfill #9450 $ @
    return MP(it_r1, it_r2);
  }@ $ \hfill %1498 $ @
  Seg diameter() { // O(n)
    Seg res;
    ll dia_sq = 0;
    auto it1 = hull.begin();
    auto it2 = up_beg;@ $ \hfill #2632 $ @
    Vec v1 = {hull.back().S.F - hull.back().F.F,
      hull.back().S.S - hull.back().F.S};
    while (it2 != hull.begin()) {
      Vec v2 = {(it2 - 1)->S.F - (it2 - 1)->F.F,
        (it2 - 1)->S.S - (it2 - 1)->F.S};@ $ \hfill #5150 $ @
      if (cross(v1, v2) > 0) break;
      --it2;
    }
    while (it2 != hull.end()) { // check all antipodal pairs
      if (dist_sq(it1->F, it2->F) > dia_sq) {@ $ \hfill #1246 $ @
        res = {it1->F, it2->F};
        dia_sq = dist_sq(res.F, res.S);
      }
      Vec v1 = {it1->S.F - it1->F.F, it1->S.S - it1->F.S};
      Vec v2 = {it2->S.F - it2->F.F, it2->S.S - it2->F.S};
      if (cross(v1, v2) == 0) {@ $ \hfill #9381 $ @
        if (dist_sq(it1->S, it2->F) > dia_sq) {
          res = {it1->S, it2->F};
          dia_sq = dist_sq(res.F, res.S);
        }
        if (dist_sq(it1->F, it2->S) > dia_sq) {@ $ \hfill #7011 $ @
          res = {it1->F, it2->S};
          dia_sq = dist_sq(res.F, res.S);
        } // report cross pairs at parallel lines.
        ++it1;
        ++it2;@ $ \hfill #5626 $ @
      } else if (cross(v1, v2) < 0) {
        ++it1;
      } else {
        ++it2;
      }@ $ \hfill #4406 $ @
    }
    return res;
  }
};@ $ \hfill %9383 $ @
\end{minted}
\section{Delaunay triangulation $\mathcal{O}(n\log n)}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
const int max_co = (1 << 28) - 5;
struct Vec {
  int x, y;
  bool operator==(const Vec &oth) { return x == oth.x && y == oth.y; }
  bool operator!=(const Vec &oth) { return !operator==(oth); }
  Vec operator-(const Vec &oth) { return {x - oth.x, y - oth.y}; }
};@ $ \hfill #2919 $ @
ll cross(Vec a, Vec b) { return (ll)a.x * b.y - (ll)a.y * b.x; }
ll dot(Vec a, Vec b) { return (ll)a.x * b.x + (ll)a.y * b.y; }
struct Edge {
  Vec tar;
  Edge *nxt;@ $ \hfill #8008 $ @
  Edge *inv = NULL;
  Edge *rep = NULL;
  bool vis = false;
};
struct Seg {@ $ \hfill #7311 $ @
  Vec a, b;
  bool operator==(const Seg &oth) { return a == oth.a && b == oth.b; }
  bool operator!=(const Seg &oth) { return !operator==(oth); }
};
ll orient(Vec a, Vec b, Vec c) {@ $ \hfill #6432 $ @
  return (ll)a.x * (b.y - c.y) + (ll)b.x * (c.y - a.y) +
         (ll)c.x * (a.y - b.y);
}@ $ \hfill %6334 $ @
bool in_c_circle(Vec *arr, Vec d) {
  if (cross(arr[1] - arr[0], arr[2] - arr[0]) == 0)
    return true; // degenerate
  ll m[3][3];
  ran(i, 0, 3) {@ $ \hfill #4264 $ @
    m[i][0] = arr[i].x - d.x;
    m[i][1] = arr[i].y - d.y;
    m[i][2] = m[i][0] * m[i][0];
    m[i][2] += m[i][1] * m[i][1];
  }@ $ \hfill #7305 $ @
  __int128 res = 0;
  res += (__int128)(m[0][0] * m[1][1] - m[0][1] * m[1][0]) * m[2][2];
  res += (__int128)(m[1][0] * m[2][1] - m[1][1] * m[2][0]) * m[0][2];
  res -= (__int128)(m[0][0] * m[2][1] - m[0][1] * m[2][0]) * m[1][2];
  return res > 0;@ $ \hfill #1845 $ @
}@ $ \hfill %6793 $ @
Edge *add_triangle(Edge *a, Edge *b, Edge *c) {
  Edge *old[] = {a, b, c};
  Edge *tmp = new Edge[3];
  ran(i, 0, 3) {
    old[i]->rep = tmp + i;@ $ \hfill #8219 $ @
    tmp[i] = {old[i]->tar, tmp + (i + 1) % 3, old[i]->inv};
    if (tmp[i].inv) tmp[i].inv->inv = tmp + i;
  }
  return tmp;
}@ $ \hfill #8178 $ @
Edge *add_point(Vec p, Edge *cur) { // returns outgoing edge
  Edge *triangle[] = {cur, cur->nxt, cur->nxt->nxt};
  ran(i, 0, 3) {
    if (orient(triangle[i]->tar, triangle[(i + 1) % 3]->tar, p) < 0)
      return NULL;@ $ \hfill #0233 $ @
  }
  ran(i, 0, 3) {
    if (triangle[i]->rep) {
      Edge *res = add_point(p, triangle[i]->rep);
      if (res)@ $ \hfill #5636 $ @
        return res; // unless we are on last layer we must exit here
    }
  }
  Edge p_as_e{p};
  Edge tmp{cur->tar};@ $ \hfill #1432 $ @
  tmp.inv = add_triangle(&p_as_e, &tmp, cur = cur->nxt);
  Edge *res = tmp.inv->nxt;
  tmp.tar = cur->tar;
  tmp.inv = add_triangle(&p_as_e, &tmp, cur = cur->nxt);
  tmp.tar = cur->tar;@ $ \hfill #8359 $ @
  res->inv = add_triangle(&p_as_e, &tmp, cur = cur->nxt);
  res->inv->inv = res;
  return res;
}
Edge *delaunay(vector<Vec> &points) {@ $ \hfill #3029 $ @
  random_shuffle(points.begin(), points.end());
  Vec arr[] = {{4 * max_co, 4 * max_co}, {-4 * max_co, max_co},
    {max_co, -4 * max_co}};
  Edge *res = new Edge[3];
  ran(i, 0, 3) res[i] = {arr[i], res + (i + 1) % 3};
  for (Vec &cur : points) {@ $ \hfill #4575 $ @
    Edge *loc = add_point(cur, res);
    Edge *out = loc;
    arr[0] = cur;
    while (true) {
      arr[1] = out->tar;@ $ \hfill #3471 $ @
      arr[2] = out->nxt->tar;
      Edge *e = out->nxt->inv;
      if (e && in_c_circle(arr, e->nxt->tar)) {
        Edge tmp{cur};
        tmp.inv = add_triangle(&tmp, out, e->nxt);
        tmp.tar = e->nxt->tar;@ $ \hfill #9851 $ @
        tmp.inv->inv = add_triangle(&tmp, e->nxt->nxt, out->nxt->nxt);
        out = tmp.inv->nxt;
        continue;
      }
      out = out->nxt->nxt->inv;@ $ \hfill #0151 $ @
      if (out->tar == loc->tar) break;
    }
  }
  return res;
}@ $ \hfill #6769 $ @@ $ \hfill %6769 $ @
void extract_triangles(Edge *cur, vector<vector<Seg> > &res) {
  if (!cur->vis) {
    bool inc = true;
    Edge *it = cur;
    do {@ $ \hfill #3769 $ @
      it->vis = true;
      if (it->rep) {
        extract_triangles(it->rep, res);
        inc = false;
      }@ $ \hfill #2104 $ @
      it = it->nxt;
    } while (it != cur);
    if (inc) {
      Edge *triangle[3] = {cur, cur->nxt, cur->nxt->nxt};
      res.resize(res.size() + 1);@ $ \hfill #6207 $ @
      vector<Seg> &tar = res.back();
      ran(i, 0, 3) {
        if ((abs(triangle[i]->tar.x) < max_co &&
              abs(triangle[(i + 1) % 3]->tar.x) < max_co))
          tar.push_back(@ $ \hfill #3011 $ @
            {triangle[i]->tar, triangle[(i + 1) % 3]->tar});
      }
      if (tar.empty()) res.pop_back();
    }
  }@ $ \hfill #8602 $ @
}@ $ \hfill %5626 $ @
\end{minted}
\section{Aho Corasick $\mathcal{O}(|\text{alpha}|\sum{\text{len}})$}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
const int alpha_size = 26;
struct Node {
  Node *nxt[alpha_size]; // May use other structures to move in trie
  Node *suffix;
  Node() { memset(nxt, 0, alpha_size * sizeof(Node *)); }
  int cnt = 0;@ $ \hfill #1006 $ @
};
Node *aho_corasick(vector<vector<char> > &dict) {
  Node *root = new Node;
  root->suffix = 0;
  vector<pair<vector<char> *, Node *> > state;@ $ \hfill #9056 $ @
  for (vector<char> &s : dict) state.emplace_back(&s, root);
  for (int i = 0; !state.empty(); ++i) {
    vector<pair<vector<char> *, Node *> > nstate;
    for (auto &cur : state) {
      Node *nxt = cur.second->nxt[(*cur.first)[i]];
      if (nxt) {@ $ \hfill #1331 $ @
        cur.second = nxt;
      } else {
        nxt = new Node;
        cur.second->nxt[(*cur.first)[i]] = nxt;
        Node *suf = cur.second->suffix;@ $ \hfill #5283 $ @
        cur.second = nxt;
        nxt->suffix = root; // set correct suffix link
        while (suf) {
          if (suf->nxt[(*cur.first)[i]]) {
            nxt->suffix = suf->nxt[(*cur.first)[i]];
            break;@ $ \hfill #3580 $ @
          }
          suf = suf->suffix;
        }
      }
      if (cur.first->size() > i + 1) nstate.push_back(cur);
    }@ $ \hfill #3263 $ @
    state = nstate;
  }
  return root;
}@ $ \hfill %2882 $ @
// auxilary functions for searhing and counting
Node *walk(Node *cur,
  char c) { // longest prefix in dict that is suffix of walked string.
  while (true) {
    if (cur->nxt[c]) return cur->nxt[c];
    if (!cur->suffix) return cur;@ $ \hfill #5414 $ @
    cur = cur->suffix;
  }
}@ $ \hfill %1529 $ @
void cnt_matches(Node *root, vector<char> &match_in) {
  Node *cur = root;
  for (char c : match_in) {
    cur = walk(cur, c);
    ++cur->cnt;@ $ \hfill #0015 $ @
  }
}@ $ \hfill %8156 $ @
void add_cnt(Node *root) { // After counting matches propagete ONCE to
                           // suffixes for final counts
  vector<Node *> to_visit = {root};
  ran(i, 0, to_visit.size()) {
    Node *cur = to_visit[i];
    ran(j, 0, alpha_size) {@ $ \hfill #0662 $ @
      if (cur->nxt[j]) to_visit.push_back(cur->nxt[j]);
    }
  }
  for (int i = to_visit.size() - 1; i > 0; --i)
    to_visit[i]->suffix->cnt += to_visit[i]->cnt;@ $ \hfill #7950 $ @
}@ $ \hfill %0488 $ @
int main() {
  int n, len;
  scanf("%d %d", &len, &n);
  vector<char> a(len + 1);
  scanf("%s", a.data());
  a.pop_back();
  for (char &c : a) c -= 'a';
  vector<vector<char> > dict(n);
  ran(i, 0, n) {
    scanf("%d", &len);
    dict[i].resize(len + 1);
    scanf("%s", dict[i].data());
    dict[i].pop_back();
    for (char &c : dict[i]) c -= 'a';
  }
  Node *root = aho_corasick(dict);
  cnt_matches(root, a);
  add_cnt(root);
  ran(i, 0, n) {
    Node *cur = root;
    for (char c : dict[i]) cur = walk(cur, c);
    printf("%d\n", cur->cnt);
  }
}
\end{minted}
\section{Suffix automaton and tree $\mathcal{O}((n+q)\log(|\text{alpha}|))$}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct Node {
  map<char, Node *> nxt_char;
  // Map is faster than hashtable and unsorted arrays
  int len; // Length of longest suffix in equivalence class.
  Node *suf;
  bool has_nxt(char c) const { return nxt_char.count(c); }
  Node *nxt(char c) {@ $ \hfill #9664 $ @
    if (!has_nxt(c)) return NULL;
    return nxt_char[c];
  }
  void set_nxt(char c, Node *node) { nxt_char[c] = node; }
  Node *split(int new_len, char c) {@ $ \hfill #8305 $ @
    Node *new_n = new Node;
    new_n->nxt_char = nxt_char;
    new_n->len = new_len;
    new_n->suf = suf;
    suf = new_n;@ $ \hfill #4595 $ @
    return new_n;
  }@ $ \hfill %3114 $ @
  // Extra functions for matching and counting
  Node *lower(int depth) {
    // move to longest suf of current with a maximum length of depth.
    if (suf->len >= depth) return suf->lower(depth);
    return this;
  }
  Node *walk(char c, int depth, int &match_len) {@ $ \hfill #2130 $ @
    // move to longest suffix of walked path that is a substring
    match_len = min(match_len, len);
    // includes depth limit(needed for finding matches)
    if (has_nxt(c)) { // as suffixes are in classes match\_len must be
                      // tracked externally
      ++match_len;
      return nxt(c)->lower(depth);
    }@ $ \hfill #9589 $ @
    if (suf) return suf->walk(c, depth, match_len);
    return this;
  }@ $ \hfill %2262 $ @
  int paths_to_end = 0;
  void set_as_end() { // All suffixes of current node are marked as
                      // ending nodes.
    paths_to_end += 1;
    if (suf) suf->set_as_end();
  }@ $ \hfill #3041 $ @
  bool vis = false;
  void calc_paths() {
    /* Call ONCE from ROOT. For each node  calculates number of ways
     * to reach an end node. paths\_to\_end is ocurence count for any
     * strings in current suffix equivalence class. */
    if (!vis) {
      vis = true;
      for (auto cur : nxt_char) {@ $ \hfill #2404 $ @
        cur.second->calc_paths();
        paths_to_end += cur.second->paths_to_end;
      }
    }
  }@ $ \hfill #7906 $ @@ $ \hfill %7906 $ @
  // Transform into suffix tree of reverse string
  map<char, Node *> tree_links;
  int end_dist = 1 << 30;
  int calc_end_dist() {
    if (end_dist == 1 << 30) {
      if (nxt_char.empty()) end_dist = 0;@ $ \hfill #7524 $ @
      for (auto cur : nxt_char)
        end_dist = min(end_dist, 1 + cur.second->calc_end_dist());
    }
    return end_dist;
  }@ $ \hfill #2021 $ @
  bool vis_t = false;
  void build_suffix_tree(string &s) { // Call ONCE from ROOT.
    if (!vis_t) {
      vis_t = true;
      if (suf)@ $ \hfill #6270 $ @
        suf->tree_links[s[s.size() - end_dist - suf->len - 1]] = this;
      for (auto cur : nxt_char) cur.second->build_suffix_tree(s);
    }
  }
};@ $ \hfill #1268 $ @
struct SufAuto {
  Node *last;
  Node *root;
  void extend(char new_c) {
    Node *nlast = new Node;@ $ \hfill #4696 $ @
    nlast->len = last->len + 1;
    Node *swn = last;
    while (swn && !swn->has_nxt(new_c)) {
      swn->set_nxt(new_c, nlast);
      swn = swn->suf;@ $ \hfill #4022 $ @
    }
    if (!swn) {
      nlast->suf = root;
    } else {
      Node *max_sbstr = swn->nxt(new_c);@ $ \hfill #7000 $ @
      if (swn->len + 1 == max_sbstr->len) {
        nlast->suf = max_sbstr;
      } else {
        Node *eq_sbstr = max_sbstr->split(swn->len + 1, new_c);
        nlast->suf = eq_sbstr;@ $ \hfill #2075 $ @
        Node *x = swn;
        while (x != 0 && x->nxt(new_c) == max_sbstr) {
          x->set_nxt(new_c, eq_sbstr);
          x = x->suf;
        }@ $ \hfill #4933 $ @
      }
    }
    last = nlast;
  }@ $ \hfill %9546 $ @
  SufAuto(string &s) {
    root = new Node;
    root->len = 0;
    root->suf = NULL;
    last = root;@ $ \hfill #9604 $ @
    for (char c : s) extend(c);
    root->calc_end_dist(); // To build suffix tree use reversed string
    root->build_suffix_tree(s);
  }
};@ $ \hfill #6251 $ @@ $ \hfill %6251 $ @
\end{minted}
\section{Dinic}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct MaxFlow {
  const static ll INF = 1e18;
  int source, sink;
  ll sink_pot = 0;
  vector<int> start, now, lvl, adj, rcap, cap_loc, bfs;
  vector<bool> visited;
  vector<ll> cap, orig_cap /*lg*/, cost;
  priority_queue<pair<ll, int>, vector<pair<ll, int> >,
    greater<pair<ll, int> > >
    dist_que; /*rg*/
  void add_flow(int idx, ll flow, bool cont = true) {
    cap[idx] -= flow;
    if (cont) add_flow(rcap[idx], -flow, false);
  }
  MaxFlow(
    const vector<tuple<int, int, ll, ll /*ly*/, ll /*ry*/> > &edges) {
    for (auto &cur : edges) { // from, to, cap, rcap/*ly*/, cost/*ry*/
      start.resize(
        max(max(get<0>(cur), get<1>(cur)) + 2, (int)start.size()));
      ++start[get<0>(cur) + 1];
      ++start[get<1>(cur) + 1];
    }
    for (int i = 1; i < start.size(); ++i) start[i] += start[i - 1];
    now = start;
    adj.resize(start.back());
    cap.resize(start.back());
    rcap.resize(start.back());
    /*ly*/ cost.resize(start.back()); /*ry*/
    for (auto &cur : edges) {
      int u, v;
      ll c, rc /*ly*/, c_cost /*ry*/;
      tie(u, v, c, rc /*ly*/, c_cost /*ry*/) = cur;
      assert(u != v);
      adj[now[u]] = v;
      adj[now[v]] = u;
      rcap[now[u]] = now[v];
      rcap[now[v]] = now[u];
      cap_loc.push_back(now[u]);
      /*ly*/ cost[now[u]] = c_cost;
      cost[now[v]] = -c_cost; /*ry*/
      cap[now[u]++] = c;
      cap[now[v]++] = rc;
      orig_cap.push_back(c);
    }
  }
  bool dinic_bfs() {
    lvl.clear();
    lvl.resize(start.size());
    bfs.clear();
    bfs.resize(1, source);
    now = start;
    lvl[source] = 1;
    for (int i = 0; i < bfs.size(); ++i) {
      int u = bfs[i];
      while (now[u] < start[u + 1]) {
        int v = adj[now[u]];
        if (/*ly*/ cost[now[u]] == 0 && /*ry*/ cap[now[u]] > 0 &&
            lvl[v] == 0) {
          lvl[v] = lvl[u] + 1;
          bfs.push_back(v);
        }
        ++now[u];
      }
    }
    return lvl[sink];
  }
  ll dinic_dfs(int u, ll flow) {
    if (u == sink) return flow;
    while (now[u] < start[u + 1]) {
      int v = adj[now[u]];
      if (lvl[v] == lvl[u] + 1 /*ly*/ && cost[now[u]] == 0 /*ry*/ &&
          cap[now[u]] != 0) {
        ll res = dinic_dfs(v, min(flow, cap[now[u]]));
        if (res) {
          add_flow(now[u], res);
          return res;
        }
      }
      ++now[u];
    }
    return 0;
  }
  /*ly*/ bool recalc_dist(bool check_imp = false) {
    now = start;
    visited.clear();
    visited.resize(start.size());
    dist_que.emplace(0, source);
    bool imp = false;
    while (!dist_que.empty()) {
      int u;
      ll dist;
      tie(dist, u) = dist_que.top();
      dist_que.pop();
      if (!visited[u]) {
        visited[u] = true;
        if (check_imp && dist != 0) imp = true;
        if (u == sink) sink_pot += dist;
        while (now[u] < start[u + 1]) {
          int v = adj[now[u]];
          if (!visited[v] && cap[now[u]])
            dist_que.emplace(dist + cost[now[u]], v);
          cost[now[u]] += dist;
          cost[rcap[now[u]++]] -= dist;
        }
      }
    }
    if (check_imp) return imp;
    return visited[sink];
  }                                        /*ry*/
  /*lp*/ bool recalc_dist_bellman_ford() { // return whether there is
                                           // a negative cycle
    int i = 0;
    for (; i < (int)start.size() - 1 && recalc_dist(true); ++i) {
    }
    return i == (int)start.size() - 1;
  } /*rp*/
  /*ly*/ pair<ll, /*ry*/ ll /*ly*/> /*ry*/ calc_flow(
    int _source, int _sink) {
    source = _source;
    sink = _sink;
    assert(max(source, sink) < start.size() - 1);
    ll tot_flow = 0;
    ll tot_cost = 0;
    /*lp*/ if (recalc_dist_bellman_ford()) {
      assert(false);
    } else {                         /*rp*/
      /*ly*/ while (recalc_dist()) { /*ry*/
        ll flow = 0;
        while (dinic_bfs()) {
          now = start;
          ll cur;
          while (cur = dinic_dfs(source, INF)) flow += cur;
        }
        tot_flow += flow;
        /*ly*/ tot_cost += sink_pot * flow; /*ry*/
      }
    }
    return /*ly*/ {/*ry*/ tot_flow /*ly*/, tot_cost} /*ry*/;
  }
  ll flow_on_edge(int idx) {
    assert(idx < cap.size());
    return orig_cap[idx] - cap[cap_loc[idx]];
  }
};
const int nmax = 1055;
int main() {
  // arguments source and sink, memory usage O(largest node index
  // +input size)
  int t;
  scanf("%d", &t);
  for (int i = 0; i < t; ++i) {
    vector<tuple<int, int, ll, ll, ll> > edges;
    int n;
    scanf("%d", &n);
    for (int j = 1; j <= n; ++j) {
      edges.emplace_back(j, 2 * n + 1, 1, 0, 0);
    }
    for (int j = 1; j <= n; ++j) {
      int card;
      scanf("%d", &card);
      edges.emplace_back(0, card, 1, 0, 0);
    }
    int ex_c;
    scanf("%d", &ex_c);
    for (int j = 0; j < ex_c; ++j) {
      int a, b;
      scanf("%d %d", &a, &b);
      if (b < a) swap(a, b);
      edges.emplace_back(a, b, nmax, 0, 1);
      edges.emplace_back(b, n + b, nmax, 0, 0);
      edges.emplace_back(n + b, a, nmax, 0, 1);
    }
    int v = 2 * n + 2;
    MaxFlow mf(edges);
    printf("%d\n", (int)mf.calc_flow(0, v - 1).second);
    // cout << mf.flow\_on\_edge(edge\_index) << endl;
  }
}
\end{minted}
\section{Min Cost Max Flow with Cycle Cancelling $\mathcal{O}(\text{cap} \cdot nm)$}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct Network {
  struct Node;
  struct Edge {
    Node *u, *v;
    int f, c, cost;@ $ \hfill #2965 $ @
    Node* from(Node* pos) {
      if (pos == u) return v;
      return u;
    }
    int getCap(Node* pos) {@ $ \hfill #4145 $ @
      if (pos == u) return c - f;
      return f;
    }
    int addFlow(Node* pos, int toAdd) {
      if (pos == u) {@ $ \hfill #6369 $ @
        f += toAdd;
        return toAdd * cost;
      } else {
        f -= toAdd;
        return -toAdd * cost;@ $ \hfill #8987 $ @
      }
    }
  };
  struct Node {
    vector<Edge*> conn;@ $ \hfill #1577 $ @
    int index;
  };
  deque<Node> nodes;
  deque<Edge> edges;
  Node* addNode() {@ $ \hfill #5057 $ @
    nodes.push_back(Node());
    nodes.back().index = nodes.size() - 1;
    return &nodes.back();
  }
  Edge* addEdge(Node* u, Node* v, int f, int c, int cost) {
    edges.push_back({u, v, f, c, cost});@ $ \hfill #5123 $ @
    u->conn.push_back(&edges.back());
    v->conn.push_back(&edges.back());
    return &edges.back();
  }
  // Assumes all needed flow has already been added
  int minCostMaxFlow() {@ $ \hfill #0927 $ @
    int n = nodes.size();
    int result = 0;
    struct State {
      int p;
      Edge* used;@ $ \hfill #7358 $ @
    };
    while (1) {
      vector<vector<State> > state(1, vector<State>(n, {0, 0}));
      for (int lev = 0; lev < n; lev++) {
        state.push_back(state[lev]);@ $ \hfill #0078 $ @
        for (int i = 0; i < n; i++) {
          if (lev == 0 || state[lev][i].p < state[lev - 1][i].p) {
            for (Edge* edge : nodes[i].conn) {
              if (edge->getCap(&nodes[i]) > 0) {
                int np =@ $ \hfill #7871 $ @
                  state[lev][i].p +
                  (edge->u == &nodes[i] ? edge->cost : -edge->cost);
                int ni = edge->from(&nodes[i])->index;
                if (np < state[lev + 1][ni].p) {
                  state[lev + 1][ni].p = np;@ $ \hfill #3940 $ @
                  state[lev + 1][ni].used = edge;
                }
              }
            }
          }@ $ \hfill #3693 $ @
        }
      }
      // Now look at the last level
      bool valid = false;
      for (int i = 0; i < n; i++)
        if (state[n - 1][i].p > state[n][i].p) {@ $ \hfill #5398 $ @
          valid = true;
          vector<Edge*> path;
          int cap = 1000000000;
          Node* cur = &nodes[i];
          int clev = n;@ $ \hfill #6663 $ @
          vector<bool> explr(n, false);
          while (!explr[cur->index]) {
            explr[cur->index] = true;
            State cstate = state[clev][cur->index];
            cur = cstate.used->from(cur);@ $ \hfill #3984 $ @
            path.push_back(cstate.used);
          }
          reverse(path.begin(), path.end());
          {
            int i = 0;@ $ \hfill #9784 $ @
            Node* cur2 = cur;
            do {
              cur2 = path[i]->from(cur2);
              i++;
            } while (cur2 != cur);@ $ \hfill #9838 $ @
            path.resize(i);
          }
          for (auto edge : path) {
            cap = min(cap, edge->getCap(cur));
            cur = edge->from(cur);@ $ \hfill #8867 $ @
          }
          for (auto edge : path) {
            result += edge->addFlow(cur, cap);
            cur = edge->from(cur);
          }@ $ \hfill #4467 $ @
        }
      if (!valid) break;
    }
    return result;
  }@ $ \hfill #4029 $ @
};@ $ \hfill %2900 $ @
\end{minted}
\section{DMST $\mathcal{O}(E \log V)$}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct EdgeDesc {
  int from, to, w;
};
struct DMST {
  struct Node;@ $ \hfill #6091 $ @
  struct Edge {
    Node *from;
    Node *tar;
    int w;
    bool inc;@ $ \hfill #2186 $ @
  };
  struct Circle {
    bool vis = false;
    vector<Edge *> cont;
    void clean(int idx);@ $ \hfill #4353 $ @
  };
  const static greater<pair<ll, Edge *> > comp;
  static vector<Circle> to_proc;
  static bool no_dmst;
  static Node *root; // Can use inline static since C++17
  struct Node {@ $ \hfill #9916 $ @
    Node *par = NULL;
    vector<pair<int, int> > out_cands; // Circ, edge idx
    vector<pair<ll, Edge *> > con;
    bool in_use = false;
    ll w = 0; // extra to add to edges in con
    Node *anc() {@ $ \hfill #0564 $ @
      if (!par) return this;
      while (par->par) par = par->par;
      return par;
    }
    void clean() {@ $ \hfill #0300 $ @
      if (!no_dmst) {
        in_use = false;
        for (auto &cur : out_cands)
          to_proc[cur.first].clean(cur.second);
      }@ $ \hfill #0747 $ @
    }
    Node *con_to_root() {
      if (anc() == root) return root;
      in_use = true;
      Node *super = this; // Will become root or the first Node
                          // encountered in a loop.
      while (super == this) {@ $ \hfill #3927 $ @
        while (
          !con.empty() && con.front().second->tar->anc() == anc()) {
          pop_heap(con.begin(), con.end(), comp);
          con.pop_back();
        }@ $ \hfill #2561 $ @
        if (con.empty()) {
          no_dmst = true;
          return root;
        }
        pop_heap(con.begin(), con.end(), comp);@ $ \hfill #8600 $ @
        auto nxt = con.back();
        con.pop_back();
        w = -nxt.first;
        if (nxt.second->tar
              ->in_use) { // anc() wouldn't change anything
          super = nxt.second->tar->anc();@ $ \hfill #6612 $ @
          to_proc.resize(to_proc.size() + 1);
        } else {
          super = nxt.second->tar->con_to_root();
        }
        if (super != root) {@ $ \hfill #7005 $ @
          to_proc.back().cont.push_back(nxt.second);
          out_cands.emplace_back(
            to_proc.size() - 1, to_proc.back().cont.size() - 1);
        } else { // Clean circles
          nxt.second->inc = true;@ $ \hfill #1096 $ @
          nxt.second->from->clean();
        }
      }
      if (super != root) { // we are some loops non first Node.
        if (con.size() > super->con.size()) {@ $ \hfill #2844 $ @
          swap(con,
            super->con); // Largest con in loop should not be copied.
          swap(w, super->w);
        }
        for (auto cur : con) {@ $ \hfill #3498 $ @
          super->con.emplace_back(
            cur.first - super->w + w, cur.second);
          push_heap(super->con.begin(), super->con.end(), comp);
        }
      }@ $ \hfill #6348 $ @
      par = super; // root or anc() of first Node encountered in a
                   // loop
      return super;
    }
  };
  Node *croot;@ $ \hfill #0309 $ @
  vector<Node> graph;
  vector<Edge> edges;
  DMST(int n, vector<EdgeDesc> &desc,
    int r) { // Self loops and multiple edges are okay.
    graph.resize(n);@ $ \hfill #8100 $ @
    croot = &graph[r];
    for (auto &cur : desc) // Edges are reversed internally
      edges.push_back(Edge{&graph[cur.to], &graph[cur.from], cur.w});
    for (int i = 0; i < desc.size(); ++i)
      graph[desc[i].to].con.emplace_back(desc[i].w, &edges[i]);
    for (int i = 0; i < n; ++i)@ $ \hfill #8811 $ @
      make_heap(graph[i].con.begin(), graph[i].con.end(), comp);
  }
  bool find() {
    root = croot;
    no_dmst = false;@ $ \hfill #5307 $ @
    for (auto &cur : graph) {
      cur.con_to_root();
      to_proc.clear();
      if (no_dmst) return false;
    }@ $ \hfill #6725 $ @
    return true;
  }@ $ \hfill %1568 $ @
  ll weight() {
    ll res = 0;
    for (auto &cur : edges) {
      if (cur.inc) res += cur.w;
    }@ $ \hfill #6369 $ @
    return res;
  }@ $ \hfill %1477 $ @
};
void DMST::Circle::clean(int idx) {
  if (!vis) {
    vis = true;
    for (int i = 0; i < cont.size(); ++i) {@ $ \hfill #6503 $ @
      if (i != idx) {
        cont[i]->inc = true;
        cont[i]->from->clean();
      }
    }@ $ \hfill #8144 $ @
  }
}
const greater<pair<ll, DMST::Edge *> > DMST::comp;
vector<DMST::Circle> DMST::to_proc;
bool DMST::no_dmst;@ $ \hfill #2354 $ @
DMST::Node *DMST::root;@ $ \hfill %2870 $ @
\end{minted}
\section{Bridges $\mathcal{O}(n)$}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct vert;
struct edge {
  bool exists = true;
  vert *dest;
  edge *rev;@ $ \hfill #8922 $ @
  edge(vert *_dest) : dest(_dest) { rev = NULL; }
  vert &operator*() { return *dest; }
  vert *operator->() { return dest; }
  bool is_bridge();
};@ $ \hfill #0116 $ @
struct vert {
  deque<edge> con;
  int val = 0;
  int seen;
  int dfs(int upd, edge *ban) { // handles multiple edges
    if (!val) {@ $ \hfill #1288 $ @
      val = upd;
      seen = val;
      for (edge &nxt : con) {
        if (nxt.exists && (&nxt) != ban)
          seen = min(seen, nxt->dfs(upd + 1, nxt.rev));
      }@ $ \hfill #8194 $ @
    }
    return seen;
  }@ $ \hfill %8624 $ @
  void remove_adj_bridges() {
    for (edge &nxt : con) {
      if (nxt.is_bridge()) nxt.exists = false;
    }
  }@ $ \hfill #7106 $ @@ $ \hfill %7106 $ @
  int cnt_adj_bridges() {
    int res = 0;
    for (edge &nxt : con) res += nxt.is_bridge();
    return res;
  }@ $ \hfill #9056 $ @@ $ \hfill %9056 $ @
};
bool edge::is_bridge() {
  return exists &&
         (dest->seen > rev->dest->val || dest->val < rev->dest->seen);
}@ $ \hfill #5223 $ @@ $ \hfill %5223 $ @
vert graph[nmax];
int main() { // Mechanics Practice BRIDGES
  int n, m;
  cin >> n >> m;
  for (int i = 0; i < m; ++i) {
    int u, v;
    scanf("%d %d", &u, &v);
    graph[u].con.emplace_back(graph + v);
    graph[v].con.emplace_back(graph + u);
    graph[u].con.back().rev = &graph[v].con.back();
    graph[v].con.back().rev = &graph[u].con.back();
  }
  graph[1].dfs(1, NULL);
  int res = 0;
  for (int i = 1; i <= n; ++i) res += graph[i].cnt_adj_bridges();
  cout << res / 2 << endl;
}
\end{minted}
\section{2-Sat $\mathcal{O}(n)$ and SCC $\mathcal{O}(n)$}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct Graph {
  int n;
  vector<vector<int> > con;
  Graph(int nsize) {
    n = nsize;@ $ \hfill #0321 $ @
    con.resize(n);
  }
  void add_edge(int u, int v) { con[u].push_back(v); }
  void top_dfs(int pos, vector<int> &result, vector<bool> &explr,
    vector<vector<int> > &revcon) {@ $ \hfill #2422 $ @
    if (explr[pos]) return;
    explr[pos] = true;
    for (auto next : revcon[pos])
      top_dfs(next, result, explr, revcon);
    result.push_back(pos);@ $ \hfill #2081 $ @
  }@ $ \hfill %7763 $ @
  vector<int> topsort() {
    vector<vector<int> > revcon(n);
    ran(u, 0, n) {
      for (auto v : con[u]) revcon[v].push_back(u);
    }@ $ \hfill #3875 $ @
    vector<int> result;
    vector<bool> explr(n, false);
    ran(i, 0, n) top_dfs(i, result, explr, revcon);
    reverse(result.begin(), result.end());
    return result;@ $ \hfill #7568 $ @
  }@ $ \hfill %5339 $ @
  void dfs(int pos, vector<int> &result, vector<bool> &explr) {
    if (explr[pos]) return;
    explr[pos] = true;
    for (auto next : con[pos]) dfs(next, result, explr);
    result.push_back(pos);@ $ \hfill #6880 $ @
  }@ $ \hfill %3565 $ @
  vector<vector<int> > scc() {
    vector<int> order = topsort();
    reverse(order.begin(), order.end());
    vector<bool> explr(n, false);
    vector<vector<int> > res;@ $ \hfill #9931 $ @
    for (auto it = order.rbegin(); it != order.rend(); ++it) {
      vector<int> comp;
      top_dfs(*it, comp, explr, con);
      sort(comp.begin(), comp.end());
      res.push_back(comp);@ $ \hfill #2243 $ @
    }
    sort(res.begin(), res.end());
    return res;
  }
};@ $ \hfill #0543 $ @@ $ \hfill %0543 $ @
int main() {
  int n, m;
  cin >> n >> m;
  Graph g(2 * m);
  ran(i, 0, n) {
    int a, sa, b, sb;
    cin >> a >> sa >> b >> sb;
    a--, b--;
    g.add_edge(2 * a + 1 - sa, 2 * b + sb);
    g.add_edge(2 * b + 1 - sb, 2 * a + sa);
  }
  vector<int> state(2 * m, 0);
  {
    vector<int> order = g.topsort();
    vector<bool> explr(2 * m, false);
    for (auto u : order) {
      vector<int> traversed;
      g.dfs(u, traversed, explr);
      if (traversed.size() > 0 && !state[traversed[0] ^ 1]) {
        for (auto c : traversed) state[c] = 1;
      }
    }
  }
  ran(i, 0, m) {
    if (state[2 * i] == state[2 * i + 1]) {
      cout << "IMPOSSIBLE\n";
      return 0;
    }
  }
  ran(i, 0, m) cout << state[2 * i + 1] << '\n';
  return 0;
}
\end{minted}
\section{Generic persistent compressed lazy segment tree}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct Seg {
  ll sum = 0;
  void recalc(const Seg &lhs_seg, int lhs_len, const Seg &rhs_seg,
    int rhs_len) {
    sum = lhs_seg.sum + rhs_seg.sum;@ $ \hfill #7684 $ @
  }
} __attribute__((packed));
struct Lazy {
  ll add;
  ll assign_val; // LLONG\_MIN if no assign;
  void init() {@ $ \hfill #7883 $ @
    add = 0;
    assign_val = LLONG_MIN;
  }
  Lazy() { init(); }
  void split(Lazy &lhs_lazy, Lazy &rhs_lazy, int len) {
    lhs_lazy = *this;@ $ \hfill #7654 $ @
    rhs_lazy = *this;
    init();
  }
  void merge(Lazy &oth, int len) {
    if (oth.assign_val != LLONG_MIN) {@ $ \hfill #0050 $ @
      add = 0;
      assign_val = oth.assign_val;
    }
    add += oth.add;
  }@ $ \hfill #2924 $ @
  void apply_to_seg(Seg &cur, int len) const {
    if (assign_val != LLONG_MIN) {
      cur.sum = len * assign_val;
    }
    cur.sum += len * add;@ $ \hfill #6280 $ @
  }
} __attribute__((packed));
@ $ \hfill %0625 $ @struct Node { // Following code should not need to be modified
  int ver;
  bool is_lazy = false;
  Seg seg;
  Lazy lazy;@ $ \hfill #6321 $ @
  Node *lc = NULL, *rc = NULL;
  void init() {
    if (!lc) {
      lc = new Node{ver};
      rc = new Node{ver};@ $ \hfill #5313 $ @
    }
  }
  Node *upd(int L, int R, int l, int r, Lazy &val, int tar_ver) {
    if (ver != tar_ver) {
      Node *rep = new Node(*this);@ $ \hfill #8874 $ @
      rep->ver = tar_ver;
      return rep->upd(L, R, l, r, val, tar_ver);
    }
    if (L >= l && R <= r) {
      val.apply_to_seg(seg, R - L);@ $ \hfill #2138 $ @
      lazy.merge(val, R - L);
      is_lazy = true;
    } else {
      init();
      int M = (L + R) / 2;@ $ \hfill #8209 $ @
      if (is_lazy) {
        Lazy l_val, r_val;
        lazy.split(l_val, r_val, R - L);
        lc = lc->upd(L, M, L, M, l_val, ver);
        rc = rc->upd(M, R, M, R, r_val, ver);@ $ \hfill #8104 $ @
        is_lazy = false;
      }
      Lazy l_val, r_val;
      val.split(l_val, r_val, R - L);
      if (l < M) lc = lc->upd(L, M, l, r, l_val, ver);
      if (M < r) rc = rc->upd(M, R, l, r, r_val, ver);
      seg.recalc(lc->seg, M - L, rc->seg, R - M);@ $ \hfill #8581 $ @
    }
    return this;
  }
  void get(int L, int R, int l, int r, Seg *&lft_res, Seg *&tmp,
    bool last_ver) {@ $ \hfill #9373 $ @
    if (L >= l && R <= r) {
      tmp->recalc(*lft_res, L - l, seg, R - L);
      swap(lft_res, tmp);
    } else {
      init();@ $ \hfill #6654 $ @
      int M = (L + R) / 2;
      if (is_lazy) {
        Lazy l_val, r_val;
        lazy.split(l_val, r_val, R - L);
        lc = lc->upd(L, M, L, M, l_val, ver + last_ver);
        lc->ver = ver;@ $ \hfill #2185 $ @
        rc = rc->upd(M, R, M, R, r_val, ver + last_ver);
        rc->ver = ver;
        is_lazy = false;
      }
      if (l < M) lc->get(L, M, l, r, lft_res, tmp, last_ver);
      if (M < r) rc->get(M, R, l, r, lft_res, tmp, last_ver);
    }@ $ \hfill #4770 $ @
  }
} __attribute__((packed));
struct SegTree {        // indexes start from 0, ranges are [beg, end)
  vector<Node *> roots; // versions start from 0
  int len;@ $ \hfill #4873 $ @
  SegTree(int _len) : len(_len) { roots.push_back(new Node{0}); }
  int upd(int l, int r, Lazy &val, bool new_ver = false) {
    Node *cur_root =
      roots.back()->upd(0, len, l, r, val, roots.size() - !new_ver);
    if (cur_root != roots.back()) roots.push_back(cur_root);
    return roots.size() - 1;@ $ \hfill #1461 $ @
  }
  Seg get(int l, int r, int ver = -1) {
    if (ver == -1) ver = roots.size() - 1;
    Seg seg1, seg2;
    Seg *pres = &seg1, *ptmp = &seg2;@ $ \hfill #9427 $ @
    roots[ver]->get(0, len, l, r, pres, ptmp, roots.size() - 1);
    return *pres;
  }
};
@ $ \hfill %7542 $ @int main() {
  int n, m; // solves Mechanics Practice LAZY
  cin >> n >> m;
  SegTree seg_tree(1 << 17);
  for (int i = 0; i < n; ++i) {
    Lazy tmp;
    scanf("%lld", &tmp.assign_val);
    seg_tree.upd(i, i + 1, tmp);
  }
  for (int i = 0; i < m; ++i) {
    int o;
    int l, r;
    scanf("%d %d %d", &o, &l, &r);
    --l;
    if (o == 1) {
      Lazy tmp;
      scanf("%lld", &tmp.add);
      seg_tree.upd(l, r, tmp);
    } else if (o == 2) {
      Lazy tmp;
      scanf("%lld", &tmp.assign_val);
      seg_tree.upd(l, r, tmp);
    } else {
      Seg res = seg_tree.get(l, r);
      printf("%lld\n", res.sum);
    }
  }
}
\end{minted}
\section{Templated HLD $\mathcal{O}(M(n) \log n)$ per query}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
class dummy {
 public:
  dummy() {}
  dummy(int, int) {}
  void set(int, int) {}@ $ \hfill #9531 $ @
  int query(int left, int right) {
    cout << this << ' ' << left << ' ' << right << endl;
  }
};@ $ \hfill %7932 $ @
/* T should be the type of the data stored in each vertex;
 * DS should be the underlying data structure that is used to peform
 * the group operation. It should have the following methods:
 * * DS () - empty constructor
 * * DS (int size, T initial) - constructs the structure with the
 * given size, initially filled with initial.
 * * void set (int index, T value) - set the value at index `index` to
 * `value`
 * * T query (int left, int right) - return the "sum" of elements
 * between left and right, inclusive.
 */
template <typename T, class DS>
class HLD {
  int vertexc;
  vector<int> *adj;
  vector<int> subtree_size;@ $ \hfill #6178 $ @
  DS structure;
  DS aux;
  void build_sizes(int vertex, int parent) {
    subtree_size[vertex] = 1;
    for (int child : adj[vertex]) {@ $ \hfill #2037 $ @
      if (child != parent) {
        build_sizes(child, vertex);
        subtree_size[vertex] += subtree_size[child];
      }
    }@ $ \hfill #6759 $ @
  }
  int cur;
  vector<int> ord;
  vector<int> chain_root;
  vector<int> par;@ $ \hfill #9593 $ @
  void build_hld(int vertex, int parent, int chain_source) {
    cur++;
    ord[vertex] = cur;
    chain_root[vertex] = chain_source;
    par[vertex] = parent;@ $ \hfill #0432 $ @
    if (adj[vertex].size() > 1 ||
        (vertex == 1 && adj[vertex].size() == 1)) {
      int big_child, big_size = -1;
      for (int child : adj[vertex]) {
        if ((child != parent) && (subtree_size[child] > big_size)) {
          big_child = child;@ $ \hfill #9151 $ @
          big_size = subtree_size[child];
        }
      }
      build_hld(big_child, vertex, chain_source);
      for (int child : adj[vertex]) {@ $ \hfill #3027 $ @
        if ((child != parent) && (child != big_child))
          build_hld(child, vertex, child);
      }
    }
  }@ $ \hfill #8562 $ @
 public:
  HLD(int _vertexc) {
    vertexc = _vertexc;
    adj = new vector<int>[vertexc + 5];
  }@ $ \hfill #3486 $ @
  void add_edge(int u, int v) {
    adj[u].push_back(v);
    adj[v].push_back(u);
  }
  void build(T initial) {@ $ \hfill #4566 $ @
    subtree_size = vector<int>(vertexc + 5);
    ord = vector<int>(vertexc + 5);
    chain_root = vector<int>(vertexc + 5);
    par = vector<int>(vertexc + 5);
    cur = 0;@ $ \hfill #2693 $ @
    build_sizes(1, -1);
    build_hld(1, -1, 1);
    structure = DS(vertexc + 5, initial);
    aux = DS(50, initial);
  }@ $ \hfill #7758 $ @
  void set(int vertex, int value) {
    structure.set(ord[vertex], value);
  }
  T query_path(
    int u, int v) { /* returns the "sum" of the path u->v */
    int cur_id = 0;@ $ \hfill #4754 $ @
    while (chain_root[u] != chain_root[v]) {
      if (ord[u] > ord[v]) {
        cur_id++;
        aux.set(cur_id, structure.query(ord[chain_root[u]], ord[u]));
        u = par[chain_root[u]];@ $ \hfill #4538 $ @
      } else {
        cur_id++;
        aux.set(cur_id, structure.query(ord[chain_root[v]], ord[v]));
        v = par[chain_root[v]];
      }@ $ \hfill #1595 $ @
    }
    cur_id++;
    aux.set(cur_id,
      structure.query(min(ord[u], ord[v]), max(ord[u], ord[v])));
    return aux.query(1, cur_id);@ $ \hfill #7150 $ @
  }@ $ \hfill %1905 $ @
  void print() {
    for (int i = 1; i <= vertexc; i++)
      cout << i << ' ' << ord[i] << ' ' << chain_root[i] << ' '
           << par[i] << endl;
  }
};
int main() {
  int vertexc;
  cin >> vertexc;
  HLD<int, dummy> hld(vertexc);
  for (int i = 0; i < vertexc - 1; i++) {
    int u, v;
    cin >> u >> v;
    hld.add_edge(u, v);
  }
  hld.build(0);
  hld.print();
  int queryc;
  cin >> queryc;
  for (int i = 0; i < queryc; i++) {
    int u, v;
    cin >> u >> v;
    hld.query_path(u, v);
    cout << endl;
  }
}
\end{minted}
\section{Templated multi dimensional BIT $\mathcal{O}(\log(n)^\text{dim})$ per query}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
// Fully overloaded any dimensional BIT, use any type for coordinates,
// elements, return\_value. Includes coordinate compression.
template <typename E_T, typename C_T, C_T n_inf, typename R_T>
struct BIT {
  vector<C_T> pos;
  vector<E_T> elems;
  bool act = false;@ $ \hfill #3273 $ @
  BIT() { pos.push_back(n_inf); }
  void init() {
    if (act) {
      for (E_T &c_elem : elems) c_elem.init();
    } else {@ $ \hfill #2594 $ @
      act = true;
      sort(pos.begin(), pos.end());
      pos.resize(unique(pos.begin(), pos.end()) - pos.begin());
      elems.resize(pos.size());
    }@ $ \hfill #7774 $ @
  }
  template <typename... loc_form>
  void update(C_T cx, loc_form... args) {
    if (act) {
      int x = lower_bound(pos.begin(), pos.end(), cx) - pos.begin();
      for (; x < (int)pos.size(); x += x & -x)@ $ \hfill #7303 $ @
        elems[x].update(args...);
    } else {
      pos.push_back(cx);
    }
  }@ $ \hfill #8505 $ @
  template <typename... loc_form>
  R_T query(C_T cx, loc_form... args) { // sum in (-inf, cx)
    R_T res = 0;
    int x = lower_bound(pos.begin(), pos.end(), cx) - pos.begin() - 1;
    for (; x > 0; x -= x & -x) res += elems[x].query(args...);
    return res;@ $ \hfill #2526 $ @
  }
};
template <typename I_T>
struct wrapped {
  I_T a = 0;@ $ \hfill #6509 $ @
  void update(I_T b) { a += b; }
  I_T query() { return a; }
  // Should never be called, needed for compilation
  void init() { DEBUG('i') }
  void update() { DEBUG('u') }
};@ $ \hfill #2858 $ @
@ $ \hfill %2858 $ @int main() {
  // retun type should be same as type inside wrapped
  BIT<BIT<wrapped<ll>, int, INT_MIN, ll>, int, INT_MIN, ll> fenwick;
  int dim = 2;
  vector<tuple<int, int, ll> > to_insert;
  to_insert.emplace_back(1, 1, 1);
  // set up all pos that are to be used for update
  for (int i = 0; i < dim; ++i) {
    for (auto &cur : to_insert)
      fenwick.update(get<0>(cur), get<1>(cur));
    // May include value which won't be used
    fenwick.init();
  }
  // actual use
  for (auto &cur : to_insert)
    fenwick.update(get<0>(cur), get<1>(cur), get<2>(cur));
  cout << fenwick.query(2, 2) << '\n';
}
\end{minted}
\section{Treap $\mathcal{O}(\log n)$ per query}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
mt19937 randgen;
struct Treap {
  struct Node {
    int key;
    int value;@ $ \hfill #5615 $ @
    unsigned int priority;
    long long total;
    Node* lch;
    Node* rch;
    Node(int new_key, int new_value) {@ $ \hfill #5698 $ @
      key = new_key;
      value = new_value;
      priority = randgen();
      total = new_value;
      lch = 0;@ $ \hfill #7232 $ @
      rch = 0;
    }
    void update() {
      total = value;
      if (lch) total += lch->total;@ $ \hfill #4295 $ @
      if (rch) total += rch->total;
    }
  };
  deque<Node> nodes;
  Node* root = 0;@ $ \hfill #9633 $ @
  pair<Node*, Node*> split(int key, Node* cur) {
    if (cur == 0) return {0, 0};
    pair<Node*, Node*> result;
    if (key <= cur->key) {
      auto ret = split(key, cur->lch);@ $ \hfill #5233 $ @
      cur->lch = ret.second;
      result = {ret.first, cur};
    } else {
      auto ret = split(key, cur->rch);
      cur->rch = ret.first;@ $ \hfill #6988 $ @
      result = {cur, ret.second};
    }
    cur->update();
    return result;
  }@ $ \hfill #7230 $ @
  Node* merge(Node* left, Node* right) {
    if (left == 0) return right;
    if (right == 0) return left;
    Node* top;
    if (left->priority < right->priority) {@ $ \hfill #6282 $ @
      left->rch = merge(left->rch, right);
      top = left;
    } else {
      right->lch = merge(left, right->lch);
      top = right;@ $ \hfill #3510 $ @
    }
    top->update();
    return top;
  }
  void insert(int key, int value) {@ $ \hfill #8918 $ @
    nodes.push_back(Node(key, value));
    Node* cur = &nodes.back();
    pair<Node*, Node*> ret = split(key, root);
    cur = merge(ret.first, cur);
    cur = merge(cur, ret.second);@ $ \hfill #9760 $ @
    root = cur;
  }
  void erase(int key) {
    Node *left, *mid, *right;
    tie(left, mid) = split(key, root);@ $ \hfill #1416 $ @
    tie(mid, right) = split(key + 1, mid);
    root = merge(left, right);
  }
  long long sum_upto(int key, Node* cur) {
    if (cur == 0) return 0;@ $ \hfill #7634 $ @
    if (key <= cur->key) {
      return sum_upto(key, cur->lch);
    } else {
      long long result = cur->value + sum_upto(key, cur->rch);
      if (cur->lch) result += cur->lch->total;@ $ \hfill #8122 $ @
      return result;
    }
  }
  long long get(int l, int r) {
    return sum_upto(r + 1, root) - sum_upto(l, root);
  }@ $ \hfill #0094 $ @
};@ $ \hfill %4959 $ @
// Solution for:
// http://codeforces.com/group/UO1GDa2Gwb/contest/219104/problem/TREAP
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(0);
  int m;
  Treap treap;
  cin >> m;
  for (int i = 0; i < m; i++) {
    int type;
    cin >> type;
    if (type == 1) {
      int x, y;
      cin >> x >> y;
      treap.insert(x, y);
    } else if (type == 2) {
      int x;
      cin >> x;
      treap.erase(x);
    } else {
      int l, r;
      cin >> l >> r;
      cout << treap.get(l, r) << endl;
    }
  }
  return 0;
}
\end{minted}
\section{Radixsort 50M 64 bit integers as single array in 1 sec}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
template <typename T>
void rsort(T *a, T *b, int size, int d = sizeof(T) - 1) {
  int b_s[256]{};
  ran(i, 0, size) { ++b_s[(a[i] >> (d * 8)) & 255]; }
  // ++b\_s[*((uchar *)(a + i) + d)];
  T *mem[257];@ $ \hfill #5369 $ @
  mem[0] = b;
  T **l_b = mem + 1;
  l_b[0] = b;
  ran(i, 0, 255) { l_b[i + 1] = l_b[i] + b_s[i]; }
  for (T *it = a; it != a + size; ++it) {@ $ \hfill #6813 $ @
    T id = ((*it) >> (d * 8)) & 255;
    *(l_b[id]++) = *it;
  }
  l_b = mem;
  if (d) {@ $ \hfill #5681 $ @
    T *l_a[256];
    l_a[0] = a;
    ran(i, 0, 255) l_a[i + 1] = l_a[i] + b_s[i];
    ran(i, 0, 256) {
      if (l_b[i + 1] - l_b[i] < 100) {@ $ \hfill #1162 $ @
        sort(l_b[i], l_b[i + 1]);
        if (d & 1) copy(l_b[i], l_b[i + 1], l_a[i]);
      } else {
        rsort(l_b[i], l_a[i], b_s[i], d - 1);
      }@ $ \hfill #7759 $ @
    }
  }
}@ $ \hfill %0571 $ @
const int nmax = 5e7;
ll arr[nmax], tmp[nmax];
int main() {
  for (int i = 0; i < nmax; ++i) arr[i] = ((ll)rand() << 32) | rand();
  rsort(arr, tmp, nmax);
  assert(is_sorted(arr, arr + nmax));
}
\end{minted}
\section{FFT 5M length/sec}
integer $c = a*b$ is accurate if $c_i < 2^{49}$
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct Complex {
  double a = 0, b = 0;
  Complex &operator/=(const int &oth) {
    a /= oth;
    b /= oth;@ $ \hfill #1139 $ @
    return *this;
  }
};
Complex operator+(const Complex &lft, const Complex &rgt) {
  return Complex{lft.a + rgt.a, lft.b + rgt.b};@ $ \hfill #8384 $ @
}
Complex operator-(const Complex &lft, const Complex &rgt) {
  return Complex{lft.a - rgt.a, lft.b - rgt.b};
}
Complex operator*(const Complex &lft, const Complex &rgt) {
  return Complex{@ $ \hfill #5371 $ @
    lft.a * rgt.a - lft.b * rgt.b, lft.a * rgt.b + lft.b * rgt.a};
}
Complex conj(const Complex &cur) { return Complex{cur.a, -cur.b}; }
void fft_rec(Complex *arr, Complex *root_pow, int len) {
  if (len != 1) {@ $ \hfill #7637 $ @
    fft_rec(arr, root_pow, len >> 1);
    fft_rec(arr + len, root_pow, len >> 1);
  }
  root_pow += len;
  for (int i = 0; i < len; ++i) {@ $ \hfill #0670 $ @
    Complex tmp = arr[i] + root_pow[i] * arr[i + len];
    arr[i + len] = arr[i] - root_pow[i] * arr[i + len];
    arr[i] = tmp;
  }
}@ $ \hfill #7078 $ @
void fft(vector<Complex> &arr, int ord, bool invert) {
  assert(arr.size() == 1 << ord);
  static vector<Complex> root_pow(1);
  static int inc_pow = 1;
  static bool is_inv = false;@ $ \hfill #0102 $ @
  if (inc_pow <= ord) {
    int idx = root_pow.size();
    root_pow.resize(1 << ord);
    for (; inc_pow <= ord; ++inc_pow) {
      for (int idx_p = 0; idx_p < 1 << (ord - 1);@ $ \hfill #3349 $ @
           idx_p += 1 << (ord - inc_pow), ++idx) {
        root_pow[idx] = Complex{cos(-idx_p * M_PI / (1 << (ord - 1))),
          sin(-idx_p * M_PI / (1 << (ord - 1)))};
        if (is_inv) root_pow[idx].b = -root_pow[idx].b;
      }@ $ \hfill #6357 $ @
    }
  }
  if (invert != is_inv) {
    is_inv = invert;
    for (Complex &cur : root_pow) cur.b = -cur.b;@ $ \hfill #7526 $ @
  }
  for (int i = 1, j = 0; i < (1 << ord); ++i) {
    int m = 1 << (ord - 1);
    bool cont = true;
    while (cont) {@ $ \hfill #0510 $ @
      cont = j & m;
      j ^= m;
      m >>= 1;
    }
    if (i < j) swap(arr[i], arr[j]);@ $ \hfill #0506 $ @
  }
  fft_rec(arr.data(), root_pow.data(), 1 << (ord - 1));
  if (invert)
    for (int i = 0; i < (1 << ord); ++i) arr[i] /= (1 << ord);
}@ $ \hfill #4380 $ @@ $ \hfill %4380 $ @
void mult_poly_mod(
  vector<int> &a, vector<int> &b, vector<int> &c) { // c += a*b
  static vector<Complex>
    arr[4]; // correct upto 0.5-2M elements(mod ~= 1e9)
  if (c.size() < 400) {@ $ \hfill #8811 $ @
    for (int i = 0; i < a.size(); ++i)
      for (int j = 0; j < b.size() && i + j < c.size(); ++j)
        c[i + j] = ((ll)a[i] * b[j] + c[i + j]) % mod;
  } else {
    int fft_ord = 32 - __builtin_clz(c.size());@ $ \hfill #4629 $ @
    if (arr[0].size() != 1 << fft_ord)
      for (int i = 0; i < 4; ++i) arr[i].resize(1 << fft_ord);
    for (int i = 0; i < 4; ++i)
      fill(arr[i].begin(), arr[i].end(), Complex{});
    for (int &cur : a)@ $ \hfill #9591 $ @
      if (cur < 0) cur += mod;
    for (int &cur : b)
      if (cur < 0) cur += mod;
    const int shift = 15;
    const int mask = (1 << shift) - 1;@ $ \hfill #2625 $ @
    for (int i = 0; i < min(a.size(), c.size()); ++i) {
      arr[0][i].a = a[i] & mask;
      arr[1][i].a = a[i] >> shift;
    }
    for (int i = 0; i < min(b.size(), c.size()); ++i) {
      arr[0][i].b = b[i] & mask;@ $ \hfill #3501 $ @
      arr[1][i].b = b[i] >> shift;
    }
    for (int i = 0; i < 2; ++i) fft(arr[i], fft_ord, false);
    for (int i = 0; i < 2; ++i) {
      for (int j = 0; j < 2; ++j) {@ $ \hfill #9971 $ @
        int tar = 2 + (i + j) / 2;
        Complex mult = {0, -0.25};
        if (i ^ j) mult = {0.25, 0};
        for (int k = 0; k < (1 << fft_ord); ++k) {
          int rev_k = ((1 << fft_ord) - k) % (1 << fft_ord);
          Complex ca = arr[i][k] + conj(arr[i][rev_k]);
          Complex cb = arr[j][k] - conj(arr[j][rev_k]);
          arr[tar][k] = arr[tar][k] + mult * ca * cb;
        }@ $ \hfill #4471 $ @
      }
    }
    for (int i = 2; i < 4; ++i) {
      fft(arr[i], fft_ord, true);
      for (int k = 0; k < (int)c.size(); ++k) {@ $ \hfill #8403 $ @
        c[k] = (c[k] + (((ll)(arr[i][k].a + 0.5) % mod)
                         << (shift * 2 * (i - 2)))) %
               mod;
        c[k] = (c[k] + (((ll)(arr[i][k].b + 0.5) % mod)
                         << (shift * (2 * (i - 2) + 1)))) %
               mod;@ $ \hfill #8289 $ @
      }
    }
  }
}@ $ \hfill %1231 $ @
\end{minted}
\section{Fast mod mult, Rabbin Miller prime check, Pollard rho factorization $\mathcal{O}(\sqrt{p})$}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
struct ModArithm {
  ull n;
  ld rec;
  ModArithm(ull _n) : n(_n) { // n in [2, 1<<63)
    rec = 1.0L / n;@ $ \hfill #0237 $ @
  }
  ull multf(ull a, ull b) { // a, b in [0, min(2*n, 1<<63))
    ull mult = (ld)a * b * rec + 0.5L;
    ll res = a * b - mult * n;
    if (res < 0) res += n;@ $ \hfill #0780 $ @
    return res; // in [0, n-1)
  }
  ull sqp1(ull a) { return multf(a, a) + 1; }
};@ $ \hfill %9493 $ @
ull pow_mod(ull a, ull n, ModArithm &arithm) {
  ull res = 1;
  for (ull i = 1; i <= n; i <<= 1) {
    if (n & i) res = arithm.multf(res, a);
    a = arithm.multf(a, a);@ $ \hfill #1758 $ @
  }
  return res;
}@ $ \hfill %2144 $ @
vector<char> small_primes = {
  2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};
bool is_prime(ull n) { // n <= 1<<63, 1M rand/s
  ModArithm arithm(n);
  if (n == 2 || n == 3) return true;@ $ \hfill #8104 $ @
  if (!(n & 1) || n == 1) return false;
  ull s = __builtin_ctz(n - 1);
  ull d = (n - 1) >> s;
  for (ull a : small_primes) {
    if (a >= n) break;@ $ \hfill #6402 $ @
    a = pow_mod(a, d, arithm);
    if (a == 1 || a == n - 1) continue;
    for (ull r = 1; r < s; ++r) {
      a = arithm.multf(a, a);
      if (a == 1) return false;@ $ \hfill #0876 $ @
      if (a == n - 1) break;
    }
    if (a != n - 1) return false;
  }
  return true;@ $ \hfill #4806 $ @
}@ $ \hfill %0975 $ @
ll pollard_rho(ll n) {
  ModArithm arithm(n);
  int cum_cnt = 64 - __builtin_clz(n);
  cum_cnt *= cum_cnt / 5 + 1;
  while (true) {@ $ \hfill #2118 $ @
    ll lv = rand() % n;
    ll v = arithm.sqp1(lv);
    int idx = 1;
    int tar = 1;
    while (true) {@ $ \hfill #5290 $ @
      ll cur = 1;
      ll v_cur = v;
      int j_stop = min(cum_cnt, tar - idx);
      for (int j = 0; j < j_stop; ++j) {
        cur = arithm.multf(cur, abs(v_cur - lv));@ $ \hfill #4468 $ @
        v_cur = arithm.sqp1(v_cur);
        ++idx;
      }
      if (!cur) {
        for (int j = 0; j < cum_cnt; ++j) {@ $ \hfill #7912 $ @
          ll g = __gcd(abs(v - lv), n);
          if (g == 1) {
            v = arithm.sqp1(v);
          } else if (g == n) {
            break;@ $ \hfill #0906 $ @
          } else {
            return g;
          }
        }
        break;@ $ \hfill #7208 $ @
      } else {
        ll g = __gcd(cur, n);
        if (g != 1) return g;
      }
      v = v_cur;@ $ \hfill #2298 $ @
      idx += j_stop;
      if (idx == tar) {
        lv = v;
        tar *= 2;
        v = arithm.sqp1(v);@ $ \hfill #1174 $ @
        ++idx;
      }
    }
  }
}@ $ \hfill #3542 $ @@ $ \hfill %3542 $ @
map<ll, int> prime_factor(ll n,
  map<ll, int> *res = NULL) { // n <= 1<<61, ~1000/s (<500/s on CF)
  if (!res) {
    map<ll, int> res_act;
    for (int p : small_primes) {@ $ \hfill #3770 $ @
      while (!(n % p)) {
        ++res_act[p];
        n /= p;
      }
    }@ $ \hfill #4612 $ @
    if (n != 1) prime_factor(n, &res_act);
    return res_act;
  }
  if (is_prime(n)) {
    ++(*res)[n];@ $ \hfill #1963 $ @
  } else {
    ll factor = pollard_rho(n);
    prime_factor(factor, res);
    prime_factor(n / factor, res);
  }@ $ \hfill #5350 $ @
  return map<ll, int>();
} // Usage: fact = prime\\_factor(n);$ \hfill %5477 $
\end{minted}
\section{Symmetric Submodular Functions; Queyrannes's algorithm}
\noindent {\bf SSF}: such function $f : V \rightarrow R$ that satisfies $f(A) = f(V/A)$
and for all $x \in V, X \subseteq Y \subseteq V$ it holds that
$f(X+x) - f(X) \leq f(Y+x) - f(Y)$.
\noindent {\bf Hereditary family}: such set $I \subseteq 2^V$ so that $X \subset Y \wedge Y \in I \Rightarrow X \in I$.
\noindent {\bf Loop}: such $v \in V$ so that ${v} \notin I$.
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mmbreaklines, frame=lines, texcomments=true, mathescape=true]{python}
def minimize():
	s = merge_all_loops()
	while size >= 3:
		t, u = find_pp()
		{u} is a possible minimizer
		tu = merge(t, u)
		if tu not in I:
			s = merge(tu, s)
	for x in V:
		{x} is a possible minimizer
def find_pp():
	W = {s} # s as in minimizer()
	todo = V/W
	ord = []
	while len(todo) > 0:
		x = min(todo, key=lambda x: f(W+{x}) - f({x}))
		W += {x}
		todo -= {x}
		ord.append(x)
	return ord[-1], ord[-2]
def enum_all_minimal_minimizers(X):
  # X is a inclusionwise minimal minimizer
	s = merge(s, X)
	yield X
	for {v} in I:
		if f({v}) == f(X):
			yield X
			s = merge(v, s)
	while size(V) >= 3:
		t, u = find_pp()
		tu = merge(t, u)
		if tu not in I:
			s = merge(tu, s)
		elif f({tu}) = f(X):
			yield tu
			s = merge(tu, s)
\end{minted}
\section{Berlekamp-Massey $O(\mathcal{L}N)$}
\begin{minted}[tabsize=2,baselinestretch=1,linenos,numbersep = 1mm, breaklines, frame=lines, escapeinside=@@, texcomments=true, mathescape=true]{tartu_icpc}
template <typename K>
static vector<K> berlekamp_massey(vector<K> ss) {
  vector<K> ts(ss.size());
  vector<K> cs(ss.size());
  cs[0] = K::unity;@ $ \hfill #0349 $ @
  fill(cs.begin() + 1, cs.end(), K::zero);
  vector<K> bs = cs;
  int l = 0, m = 1;
  K b = K::unity;
  for (int k = 0; k < (int)ss.size(); k++) {@ $ \hfill #4390 $ @
    K d = ss[k];
    assert(l <= k);
    for (int i = 1; i <= l; i++) d += cs[i] * ss[k - i];
    if (d == K::zero) {
      m++;@ $ \hfill #8445 $ @
    } else if (2 * l <= k) {
      K w = d / b;
      ts = cs;
      for (int i = 0; i < (int)cs.size() - m; i++)
        cs[i + m] -= w * bs[i];@ $ \hfill #9661 $ @
      l = k + 1 - l;
      swap(bs, ts);
      b = d;
      m = 1;
    } else {@ $ \hfill #2815 $ @
      K w = d / b;
      for (int i = 0; i < (int)cs.size() - m; i++)
        cs[i + m] -= w * bs[i];
      m++;
    }@ $ \hfill #8888 $ @
  }
  cs.resize(l + 1);
  while (cs.back() == K::zero) cs.pop_back();
  return cs;
}@ $ \hfill #6267 $ @@ $ \hfill %6267 $ @
\end{minted}
\end{document}
